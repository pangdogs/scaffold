package main

import (
	"fmt"
	"git.golaxy.org/core/utils/generic"
	"github.com/spf13/viper"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

func genGoCode(outDir string) {
	extensions, err := parseExtensions(protoregistry.GlobalTypes)
	if err != nil {
		panic(fmt.Errorf("解析Protobuf文件失败，%s", err))
	}

	var msgDecls generic.SliceMap[string, protoreflect.MessageType]

	protoregistry.GlobalTypes.RangeMessages(func(msg protoreflect.MessageType) bool {
		isTable := proto.GetExtension(msg.Descriptor().Options(), extensions.IsTable).(bool)
		if !isTable {
			return true
		}
		msgDecls.Add(string(msg.Descriptor().Name()), msg)
		return true
	})

	const tmpl = `{{.Comment}}

package {{.Package}}

import (
	"git.golaxy.org/scaffold/tools/excelc/excelutils"
	"path/filepath"
)

type Tables struct {
	{{- range .Tables}}
	{{.K}} *{{.K}}
	{{- end}}
}

func (tabs *Tables) LoadFromBinaryFiles(dir string) error {
	{{- range .Tables}}
	tabs.{{.K}} = &{{.K}}{}
	if err := excelutils.LoadTableFromBinaryFile(tabs.{{.K}}, filepath.Join(dir, "{{.K}}.bin")); err != nil {
		return err
	}
	{{- end}}
	return nil
}

func (tabs *Tables) LoadFromJsonFiles(dir string) error {
	{{- range .Tables}}
	tabs.{{.K}} = &{{.K}}{}
	if err := excelutils.LoadTableFromJsonFile(tabs.{{.K}}, filepath.Join(dir, "{{.K}}.json")); err != nil {
		return err
	}
	{{- end}}
	return nil
}
`

	type TmplArgs struct {
		Comment string
		Package string
		Tables  generic.SliceMap[string, protoreflect.MessageType]
	}

	args := TmplArgs{
		Comment: fmt.Sprintf(`// Code generated by %[1]s; DO NOT EDIT.
// Command: %[1]s %[2]s
// Note: This file is auto-generated. DO NOT EDIT THIS FILE DIRECTLY.`, strings.TrimSuffix(filepath.Base(os.Args[0]), filepath.Ext(os.Args[0])), strings.Join(os.Args[1:], " ")),
		Package: viper.GetString("pb_package"),
		Tables:  msgDecls,
	}

	outFilePath, _ := filepath.Abs(filepath.Join(outDir, "tables.go"))

	t := template.Must(template.New("code").Parse(tmpl))

	os.MkdirAll(outDir, os.ModePerm)

	file, err := os.OpenFile(outFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	err = t.Execute(file, args)
	if err != nil {
		panic(err)
	}
}
