/*
 * This file is part of Golaxy Distributed Service Development Framework.
 *
 * Golaxy Distributed Service Development Framework is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * Golaxy Distributed Service Development Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Golaxy Distributed Service Development Framework. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright (c) 2024 pangdogs.
 */

package main

import (
	"fmt"
	"git.golaxy.org/framework/net/gap/variant"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"hash/fnv"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if f.Generate {
				generateFile(gen, f)
			}
		}
		return nil
	})
}

const (
	protoPackage = protogen.GoImportPath("google.golang.org/protobuf/proto")
	mapsPackage  = protogen.GoImportPath("maps")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	fileName := file.GeneratedFilenamePrefix + ".safe.go"
	g := gen.NewGeneratedFile(fileName, file.GoImportPath)

	genGeneratedHeader(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	g.Import(protoPackage)

	for _, m := range file.Messages {
		g.P("// Safe 安全访问")
		g.P("func (x *", m.GoIdent, ") Safe() *", m.GoIdent, " {")

		for _, f := range m.Fields {
			if f.Desc.IsList() {
				continue
			}

			if f.Desc.IsMap() {
				var mapValue string

				switch f.Desc.MapValue().Kind() {
				case protoreflect.MessageKind, protoreflect.GroupKind:
					mapValue = "*" + string(f.Desc.MapValue().Message().Name())
				default:
					mapValue = f.Desc.MapValue().Kind().String()
				}

				g.P("\tif x.", f.GoName, " == nil {")
				g.P("\t\tx.", f.GoName, " = map[", f.Desc.MapKey().Kind(), "]", mapValue, "{}")
				g.P("\t}")
				continue
			}

			switch f.Desc.Kind() {
			case protoreflect.MessageKind, protoreflect.GroupKind:
				g.P("\tif x.", f.GoName, " == nil {")
				g.P("\t\tx.", f.GoName, " = &", f.Desc.Message().Name(), "{}")
				g.P("\t}")
				continue
			}
		}

		g.P("\treturn x")
		g.P("}")
		g.P()

		g.P("// Clone 克隆")
		g.P("func (x *", m.GoIdent, ") Clone() *", m.GoIdent, " {")
		g.P("\treturn ", protoPackage.Ident("Clone"), "(x).(*", m.GoIdent, ")")
		g.P("}")

		for _, f := range m.Fields {
			if f.Desc.IsList() {
				continue
			}

			if f.Desc.IsMap() {
				var mapValue string

				switch f.Desc.MapValue().Kind() {
				case protoreflect.MessageKind, protoreflect.GroupKind:
					mapValue = "*" + string(f.Desc.MapValue().Message().Name())
				default:
					mapValue = f.Desc.MapValue().Kind().String()
				}

				mapDecl := fmt.Sprintf("map[%s]%s", f.Desc.MapKey().Kind(), mapValue)

				g.P("// Get", f.GoName, "Safe 安全访问字段")
				g.P("func (x *", m.GoIdent, ") Get", f.GoName, "Safe() ", mapDecl, " {")
				g.P("\treturn x.Safe().", f.GoName)
				g.P("}")
				g.P()
				continue
			}

			switch f.Desc.Kind() {
			case protoreflect.MessageKind, protoreflect.GroupKind:
				g.P("// Get", f.GoName, "Safe 安全访问字段")
				g.P("func (x *", m.GoIdent, ") Get", f.GoName, "Safe() *", f.Desc.Message().Name(), " {")
				g.P("\treturn x.Safe().", f.GoName)
				g.P("}")
				g.P()
				continue
			}
		}

		for _, f := range m.Fields {
			if f.Desc.IsList() {
				continue
			}

			if f.Desc.IsMap() {
				var mapValue string

				switch f.Desc.MapValue().Kind() {
				case protoreflect.MessageKind, protoreflect.GroupKind:
					mapValue = "*" + string(f.Desc.MapValue().Message().Name())
				default:
					mapValue = f.Desc.MapValue().Kind().String()
				}

				mapDecl := fmt.Sprintf("map[%s]%s", f.Desc.MapKey().Kind(), mapValue)

				g.P("// Get", f.GoName, "Clone 克隆字段")
				g.P("func (x *", m.GoIdent, ") Get", f.GoName, "Clone() ", mapDecl, " {")
				g.P("\treturn ", mapsPackage.Ident("Clone"), "(x.", f.GoName, ")")
				g.P("}")
				g.P()
				continue
			}

			switch f.Desc.Kind() {
			case protoreflect.MessageKind, protoreflect.GroupKind:
				g.P("// Get", f.GoName, "Clone 克隆字段")
				g.P("func (x *", m.GoIdent, ") Get", f.GoName, "Clone() *", f.Desc.Message().Name(), " {")
				g.P("\treturn x.", f.GoName, ".Clone()")
				g.P("}")
				g.P()
				continue
			}
		}
	}
}

func genGeneratedHeader(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-go-safe. DO NOT EDIT.")

	g.P("// versions:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc        ", protocVersion)

	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
}

func makeTypeId(pkgName, msgName string) variant.TypeId {
	hash := fnv.New32a()
	hash.Write([]byte(pkgName + "." + msgName))
	return variant.TypeId(variant.TypeId_Customize + hash.Sum32())
}
