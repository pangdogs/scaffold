/*
 * This file is part of Golaxy Distributed Service Development Framework.
 *
 * Golaxy Distributed Service Development Framework is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * Golaxy Distributed Service Development Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Golaxy Distributed Service Development Framework. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright (c) 2024 pangdogs.
 */

package main

import (
	"fmt"
	"git.golaxy.org/framework/net/gap/variant"
	"google.golang.org/protobuf/compiler/protogen"
	"hash/fnv"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if f.Generate {
				generateFile(gen, f)
			}
		}
		return nil
	})
}

const (
	protoPackage   = protogen.GoImportPath("google.golang.org/protobuf/proto")
	variantPackage = protogen.GoImportPath("git.golaxy.org/framework/net/gap/variant")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	fileName := file.GeneratedFilenamePrefix + ".variant.go"
	g := gen.NewGeneratedFile(fileName, file.GoImportPath)

	genGeneratedHeader(gen, file, g)

	g.P("package ", file.GoPackageName)
	g.P()

	g.Import(protoPackage)

	g.P("func init() {")
	for _, m := range file.Messages {
		g.P(variantPackage.Ident("VariantCreator"), "().Declare(&", m.GoIdent, "{})")
	}
	g.P("}")

	for _, m := range file.Messages {
		g.P("// Read implements io.Reader")
		g.P("func (x *", m.GoIdent, ") Read(p []byte) (int, error) {")
		g.P("\t_, err  := proto.MarshalOptions{}.MarshalAppend(p[:0], x)")
		g.P("\tif err != nil {")
		g.P("\t\treturn 0, err")
		g.P("\t}")
		g.P("\treturn x.Size(), nil")
		g.P("}")
		g.P()

		g.P("// Write implements io.Writer")
		g.P("func (x *", m.GoIdent, ") Write(p []byte) (int, error) {")
		g.P("\tif err := proto.Unmarshal(p, x); err != nil {")
		g.P("\t\treturn 0, err")
		g.P("\t}")
		g.P("\treturn x.Size(), nil")
		g.P("}")
		g.P()

		g.P("// Size 大小")
		g.P("func (x *", m.GoIdent, ") Size() int {")
		g.P("\treturn ", protoPackage.Ident("Size"), "(x)")
		g.P("}")
		g.P()

		g.P("// TypeId 类型")
		g.P("func (x *", m.GoIdent, ") TypeId() ", variantPackage.Ident("TypeId"), " {")
		g.P("\treturn ", makeTypeId(string(file.Desc.Package()), string(m.Desc.Name())), "")
		g.P("}")
		g.P()

		g.P("// Indirect 原始值")
		g.P("func (x *", m.GoIdent, ") Indirect() any {")
		g.P("\treturn x")
		g.P("}")
		g.P()
	}
}

func genGeneratedHeader(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-go-variant. DO NOT EDIT.")

	g.P("// versions:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc        ", protocVersion)

	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
}

func makeTypeId(pkgName, msgName string) variant.TypeId {
	hash := fnv.New32a()
	hash.Write([]byte(pkgName + "." + msgName))
	return variant.TypeId(variant.TypeId_Customize + hash.Sum32())
}
